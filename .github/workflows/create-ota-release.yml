# .github/workflows/create-ota-release.yml
name: ğŸš€ Create OTA Release

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'ğŸ¯ Target Environment'
        type: choice
        options:
          - dev
          - production
        default: 'dev'
        required: true
      
      services_to_include:
        description: 'ğŸ“¦ Services (comma-separated: hub-bl654,hub-n2k,hub-tbclient)'
        type: string
        default: 'hub-bl654,hub-n2k,hub-n2kclient,hub-provisioning,hub-tbclient'
        required: true
      
      service_versions:
        description: 'ğŸ·ï¸ Versions (service:version pairs: hub-bl654:main,hub-n2k:v1.2.3)'
        type: string
        default: 'hub-bl654:main,hub-n2k:main,hub-n2kclient:main,hub-provisioning:main,hub-tbclient:main'
        required: true
      
      include_hub_ota:
        description: 'âš ï¸ Include hub-ota for self-update'
        type: boolean
        default: false
      
      hub_ota_version:
        description: 'â””â”€ hub-ota version (if included)'
        type: string
        default: 'main'
      
      release_notes:
        description: 'ğŸ“ Release Notes'
        type: string
        required: true
      
      create_github_release:
        description: 'ğŸ“¢ Create GitHub Release'
        type: boolean
        default: true

jobs:
  build-release:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: write  # Need this to create releases
    
    steps:
      - name: ğŸ“‹ Parse and Display Configuration
        id: parse
        run: |
          echo "========================================="
          echo "ğŸ“¦ OTA RELEASE BUILD"
          echo "========================================="
          echo "Environment: ${{ inputs.environment }} ğŸ¯"
          echo "Release Engineer: ${{ github.actor }}"
          echo "Build ID: ${{ github.run_id }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo ""
          echo "Parsing service configuration..."
          echo ""
          
          # Generate release tag
          TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
          if [ "${{ inputs.environment }}" == "production" ]; then
            RELEASE_TAG="release-prod-${TIMESTAMP}"
            RELEASE_NAME="Production Release ${TIMESTAMP}"
          else
            RELEASE_TAG="release-dev-${TIMESTAMP}"
            RELEASE_NAME="Development Release ${TIMESTAMP}"
          fi
          
          echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV
          echo "RELEASE_NAME=${RELEASE_NAME}" >> $GITHUB_ENV
          echo "TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV
          
          # Parse services and versions
          cat > parse_config.py << 'EOF'
          import sys
          import json
          import os
          
          services_input = "${{ inputs.services_to_include }}"
          versions_input = "${{ inputs.service_versions }}"
          
          # Parse services list
          services = [s.strip() for s in services_input.split(',') if s.strip()]
          
          # Parse versions into dict
          version_map = {}
          for pair in versions_input.split(','):
              if ':' in pair:
                  service, version = pair.strip().split(':', 1)
                  version_map[service.strip()] = version.strip()
          
          # Build final configuration
          config = {}
          for service in services:
              config[service] = version_map.get(service, 'main')
          
          # Add hub-ota if requested
          if "${{ inputs.include_hub_ota }}" == "true":
              config["hub-ota"] = "${{ inputs.hub_ota_version }}"
          
          # Write to GitHub output file properly
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"SERVICE_CONFIG<<EOF\n")
              f.write(json.dumps(config, indent=2))
              f.write("\nEOF\n")
          
          # Display for logs (to stderr to avoid interfering with output)
          print("\nServices to Include:", file=sys.stderr)
          print("-------------------", file=sys.stderr)
          for service, version in config.items():
              marker = "âš ï¸" if service == "hub-ota" else "âœ“"
              print(f"  {marker} {service} @ {version}", file=sys.stderr)
          
          print(f"\nTotal services: {len(config)}", file=sys.stderr)
          EOF
          
          python3 parse_config.py
          echo "========================================="
      
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: ğŸ”§ Setup Environment
        run: |
          if [ "${{ inputs.environment }}" == "production" ]; then
            echo "ğŸ“Œ Using production configuration"
            echo "SIGNING_KEY_NAME=OTA_SIGNING_KEY_PROD" >> $GITHUB_ENV
            echo "TB_TENANT=production-tenant" >> $GITHUB_ENV
          else
            echo "ğŸ“Œ Using development configuration"  
            echo "SIGNING_KEY_NAME=OTA_SIGNING_KEY_DEV" >> $GITHUB_ENV
            echo "TB_TENANT=dev-tenant" >> $GITHUB_ENV
          fi
      
      - name: ğŸ”¨ Build Service Packages
        run: |
          mkdir -p build/services
          echo "# Service Build Report" > build/build_report.txt
          echo "Environment: ${{ inputs.environment }}" >> build/build_report.txt
          echo "Build Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> build/build_report.txt
          echo "" >> build/build_report.txt
          
          # Parse service config
          cat > build_services.py << 'EOF'
          import json
          import subprocess
          import os
          import sys
          
          # Get service configuration from previous step
          config_json = '''${{ steps.parse.outputs.SERVICE_CONFIG }}'''
          config = json.loads(config_json)
          
          services_file = open("build/services.txt", "w")
          report_file = open("build/build_report.txt", "a")
          
          failed_count = 0
          success_count = 0
          
          for service_name, version_ref in config.items():
              print(f"ğŸ“¦ Building {service_name}...")
              
              # Check if directory exists
              if not os.path.exists(service_name):
                  print(f"  âš ï¸ Warning: {service_name} directory not found, skipping")
                  report_file.write(f"SKIPPED: {service_name} - directory not found\n")
                  continue
              
              # Checkout specific version
              try:
                  # Try to checkout the specified ref
                  result = subprocess.run(
                      ["git", "checkout", version_ref, "--", f"{service_name}/"],
                      capture_output=True,
                      text=True
                  )
                  
                  if result.returncode != 0:
                      # If it's a commit hash, try without the path restriction
                      if len(version_ref) >= 7 and all(c in '0123456789abcdef' for c in version_ref[:7]):
                          subprocess.run(
                              ["git", "checkout", version_ref],
                              check=True,
                              capture_output=True
                          )
                      else:
                          raise Exception(f"Failed to checkout: {result.stderr}")
                  
                  # Get version string  
                  version_string = subprocess.run(
                      ["git", "describe", "--tags", "--always", "--long"],
                      capture_output=True,
                      text=True
                  ).stdout.strip()
                  
                  if not version_string:
                      version_string = subprocess.run(
                          ["git", "rev-parse", "--short", "HEAD"],
                          capture_output=True,
                          text=True
                      ).stdout.strip()
                  
                  full_version = f"{service_name}_{version_string}"
                  
                  # Copy to build directory
                  subprocess.run(
                      ["cp", "-r", service_name, f"build/services/{full_version}"],
                      check=True
                  )
                  
                  # Record success
                  services_file.write(f"{service_name}:{full_version}:{version_ref}\n")
                  report_file.write(f"SUCCESS: {service_name} -> {full_version} (ref: {version_ref})\n")
                  print(f"  âœ… Built {full_version}")
                  success_count += 1
                  
              except Exception as e:
                  print(f"  âŒ Failed to build {service_name} @ {version_ref}: {e}")
                  report_file.write(f"FAILED: {service_name} @ {version_ref} - {str(e)}\n")
                  failed_count += 1
          
          services_file.close()
          report_file.close()
          
          print("\nğŸ“Š Build Summary:")
          print("-----------------")
          print(f"âœ… Success: {success_count}")
          print(f"âŒ Failed: {failed_count}")
          
          if failed_count > 0:
              sys.exit(1)
          EOF
          
          python3 build_services.py
          
          echo ""
          echo "ğŸ“Š Detailed Build Report:"
          cat build/build_report.txt | grep -E "^(SUCCESS|FAILED|SKIPPED)" || echo "No services built"
      
      - name: ğŸ“ Create Manifest
        run: |
          python3 << 'EOF'
          import json
          import os
          from datetime import datetime
          
          services = {}
          update_order = []
          
          # Parse built services
          try:
              with open('build/services.txt') as f:
                  for line in f:
                      if line.strip():
                          parts = line.strip().split(':')
                          if len(parts) == 3:
                              name, version_dir, ref = parts
                              services[name] = {
                                  'version_directory': version_dir,
                                  'git_reference': ref,
                                  'built_at': datetime.utcnow().isoformat() + 'Z'
                              }
                              update_order.append(name)
          except FileNotFoundError:
              print("No services.txt found - no services were built")
              exit(1)
          
          # Move hub-ota to the end if present
          if 'hub-ota' in update_order:
              update_order.remove('hub-ota')
              update_order.append('hub-ota')
          
          manifest = {
              'release_id': os.environ['GITHUB_RUN_ID'],
              'release_tag': os.environ.get('RELEASE_TAG', 'unknown'),
              'environment': '${{ inputs.environment }}',
              'thingsboard_tenant': os.environ.get('TB_TENANT', 'unknown'),
              'created_by': '${{ github.actor }}',
              'created_at': datetime.utcnow().isoformat() + 'Z',
              'release_notes': '''${{ inputs.release_notes }}''',
              'services': services,
              'update_order': update_order,
              'self_update': 'hub-ota' in services,
              'github_run_url': f"https://github.com/${{github.repository}}/actions/runs/${{github.run_id}}",
              'input_configuration': {
                  'services_requested': '${{ inputs.services_to_include }}',
                  'versions_requested': '${{ inputs.service_versions }}'
              }
          }
          
          with open('build/manifest.json', 'w') as f:
              json.dump(manifest, f, indent=2)
          
          print("ğŸ“‹ Manifest created successfully")
          print(json.dumps(manifest, indent=2))
          EOF
      
      - name: ğŸ“¦ Create OTA Package
        run: |
          cd build
          zip -r ../ota_package_${{ inputs.environment }}.zip . -q
          cd ..
          
          echo "ğŸ“¦ Package created: ota_package_${{ inputs.environment }}.zip"
          echo "ğŸ“ Size: $(du -h ota_package_${{ inputs.environment }}.zip | cut -f1)"
          echo ""
          echo "ğŸ“ Package contents:"
          unzip -l ota_package_${{ inputs.environment }}.zip | grep -E "services/hub-" | head -20 || echo "  No hub services found"
          echo ""
          echo "Total files: $(unzip -l ota_package_${{ inputs.environment }}.zip | tail -1)"
      
      - name: ğŸ” Sign Package
        run: |
          # Determine which key to use based on environment
          if [ "${{ inputs.environment }}" == "production" ]; then
            SIGNING_KEY="${{ secrets.OTA_SIGNING_KEY_PROD }}"
            KEY_NAME="OTA_SIGNING_KEY_PROD"
          else
            SIGNING_KEY="${{ secrets.OTA_SIGNING_KEY_DEV }}"
            KEY_NAME="OTA_SIGNING_KEY_DEV"
          fi
          
          if [ -z "$SIGNING_KEY" ]; then
            echo "âš ï¸ Warning: No signing key found ($KEY_NAME)"
            echo "âš ï¸ Creating unsigned package for ${{ inputs.environment }}"
            
            mkdir final
            mv ota_package_${{ inputs.environment }}.zip final/package.zip
            cp build/manifest.json final/
            echo '{"signed": false, "environment": "${{ inputs.environment }}"}' > final/signature.json
          else
            echo "ğŸ” Signing package with $KEY_NAME"
            
            # Write the key directly - no base64 decoding needed!
            cat > private_key.pem << 'EOF'
          ${{ inputs.environment == 'production' && secrets.OTA_SIGNING_KEY_PROD || secrets.OTA_SIGNING_KEY_DEV }}
          EOF
            
            # Sign the package
            openssl dgst -sha256 -sign private_key.pem \
              -out ota_package_${{ inputs.environment }}.zip.sig \
              ota_package_${{ inputs.environment }}.zip
            
            # Clean up the key immediately
            rm private_key.pem
            
            # Create final package with signature
            mkdir final
            mv ota_package_${{ inputs.environment }}.zip final/package.zip
            
            # Include signature as base64 in JSON (for easy transport)
            SIGNATURE_B64=$(base64 -w0 ota_package_${{ inputs.environment }}.zip.sig)
            echo "{\"signature\":\"${SIGNATURE_B64}\", \"signed\": true, \"environment\": \"${{ inputs.environment }}\"}" > final/signature.json
            
            cp build/manifest.json final/
            
            # Clean up signature file
            rm ota_package_${{ inputs.environment }}.zip.sig
          fi
          
          # Create final archive
          cd final
          FILENAME="ota_release_${{ inputs.environment }}_${TIMESTAMP}.zip"
          zip -r ../${FILENAME} . -q
          cd ..
          
          echo "RELEASE_FILENAME=${FILENAME}" >> $GITHUB_ENV
          echo "âœ… Package ready: ${FILENAME}"
          echo "ğŸ“ Final size: $(du -h ${FILENAME} | cut -f1)"
          
