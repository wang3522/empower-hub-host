# .github/workflows/create-ota-release.yml
name: 🚀 Create OTA Release

on:
  workflow_dispatch:
    inputs:
      environment:
        description: '🎯 Target Environment'
        type: choice
        options:
          - dev
          - production
        default: 'dev'
        required: true
      
      services_to_include:
        description: '📦 Services (comma-separated: hub-bl654,hub-n2k,hub-tbclient)'
        type: string
        default: 'hub-bl654,hub-n2k,hub-n2kclient,hub-provisioning,hub-tbclient'
        required: true
      
      service_versions:
        description: '🏷️ Versions (service:version pairs: hub-bl654:main,hub-n2k:v1.2.3)'
        type: string
        default: 'hub-bl654:main,hub-n2k:main,hub-n2kclient:main,hub-provisioning:main,hub-tbclient:main'
        required: true
      
      include_hub_ota:
        description: '⚠️ Include hub-ota for self-update'
        type: boolean
        default: false
      
      hub_ota_version:
        description: '└─ hub-ota version (if included)'
        type: string
        default: 'main'
      
      release_notes:
        description: '📝 Release Notes'
        type: string
        required: true
      
      create_github_release:
        description: '📢 Create GitHub Release'
        type: boolean
        default: true

jobs:
  build-release:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: write  # Need this to create releases
    
    steps:
      - name: 📋 Parse and Display Configuration
        id: parse
        run: |
          echo "========================================="
          echo "📦 OTA RELEASE BUILD"
          echo "========================================="
          echo "Environment: ${{ inputs.environment }} 🎯"
          echo "Release Engineer: ${{ github.actor }}"
          echo "Build ID: ${{ github.run_id }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo ""
          echo "Parsing service configuration..."
          echo ""
          
          # Generate release tag
          TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
          if [ "${{ inputs.environment }}" == "production" ]; then
            RELEASE_TAG="release-prod-${TIMESTAMP}"
            RELEASE_NAME="Production Release ${TIMESTAMP}"
          else
            RELEASE_TAG="release-dev-${TIMESTAMP}"
            RELEASE_NAME="Development Release ${TIMESTAMP}"
          fi
          
          echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV
          echo "RELEASE_NAME=${RELEASE_NAME}" >> $GITHUB_ENV
          echo "TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV
          
          # Parse services and versions
          cat > parse_config.py << 'EOF'
          import sys
          import json
          import os
          
          services_input = "${{ inputs.services_to_include }}"
          versions_input = "${{ inputs.service_versions }}"
          
          # Parse services list
          services = [s.strip() for s in services_input.split(',') if s.strip()]
          
          # Parse versions into dict
          version_map = {}
          for pair in versions_input.split(','):
              if ':' in pair:
                  service, version = pair.strip().split(':', 1)
                  version_map[service.strip()] = version.strip()
          
          # Build final configuration
          config = {}
          for service in services:
              config[service] = version_map.get(service, 'main')
          
          # Add hub-ota if requested
          if "${{ inputs.include_hub_ota }}" == "true":
              config["hub-ota"] = "${{ inputs.hub_ota_version }}"
          
          # Write to GitHub output file properly
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"SERVICE_CONFIG<<EOF\n")
              f.write(json.dumps(config, indent=2))
              f.write("\nEOF\n")
          
          # Display for logs (to stderr to avoid interfering with output)
          print("\nServices to Include:", file=sys.stderr)
          print("-------------------", file=sys.stderr)
          for service, version in config.items():
              marker = "⚠️" if service == "hub-ota" else "✓"
              print(f"  {marker} {service} @ {version}", file=sys.stderr)
          
          print(f"\nTotal services: {len(config)}", file=sys.stderr)
          EOF
          
          python3 parse_config.py
          echo "========================================="
      
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: 🔍 Debug - Check Repository Structure
        run: |
          echo "=== Current directory structure ==="
          ls -la
          echo ""
          echo "=== Looking for service directories ==="
          for service in hub-bl654 hub-n2k hub-n2kclient hub-provisioning hub-tbclient hub-ota; do
            if [ -d "$service" ]; then
              echo "✅ Found: $service"
            else
              echo "❌ Missing: $service"
            fi
          done
          echo ""
          echo "=== All directories starting with 'hub' ==="
          find . -maxdepth 2 -type d -name "hub*" 2>/dev/null || echo "No hub directories found"
      
      - name: 🔧 Setup Environment
        run: |
          if [ "${{ inputs.environment }}" == "production" ]; then
            echo "📌 Using production configuration"
            echo "SIGNING_KEY_NAME=OTA_SIGNING_KEY_PROD" >> $GITHUB_ENV
            echo "TB_TENANT=production-tenant" >> $GITHUB_ENV
          else
            echo "📌 Using development configuration"  
            echo "SIGNING_KEY_NAME=OTA_SIGNING_KEY_DEV" >> $GITHUB_ENV
            echo "TB_TENANT=dev-tenant" >> $GITHUB_ENV
          fi
      
      - name: 🔨 Build Service Packages
        run: |
          mkdir -p build/services
          echo "# Service Build Report" > build/build_report.txt
          echo "Environment: ${{ inputs.environment }}" >> build/build_report.txt
          echo "Build Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> build/build_report.txt
          echo "" >> build/build_report.txt
          
          # Parse service config - FIXED to handle missing directories better
          cat > build_services.py << 'EOF'
          import json
          import subprocess
          import os
          import sys
          
          # Get service configuration from previous step
          config_json = '''${{ steps.parse.outputs.SERVICE_CONFIG }}'''
          config = json.loads(config_json)
          
          services_file = open("build/services.txt", "w")
          report_file = open("build/build_report.txt", "a")
          
          failed_count = 0
          success_count = 0
          skipped_count = 0
          
          # First, let's see what directories actually exist
          print("Checking for service directories...")
          existing_dirs = [d for d in os.listdir('.') if os.path.isdir(d) and d.startswith('hub')]
          print(f"Found directories: {existing_dirs}")
          
          for service_name, version_ref in config.items():
              print(f"📦 Building {service_name}...")
              
              # Check if directory exists
              if not os.path.exists(service_name):
                  print(f"  ⚠️ Warning: {service_name} directory not found, skipping")
                  report_file.write(f"SKIPPED: {service_name} - directory not found\n")
                  skipped_count += 1
                  continue
              
              # For testing, let's just copy what exists without checkout
              try:
                  # Get version string  
                  version_string = subprocess.run(
                      ["git", "describe", "--tags", "--always", "--long"],
                      capture_output=True,
                      text=True
                  ).stdout.strip()
                  
                  if not version_string:
                      version_string = subprocess.run(
                          ["git", "rev-parse", "--short", "HEAD"],
                          capture_output=True,
                          text=True
                      ).stdout.strip()
                  
                  full_version = f"{service_name}_{version_string}"
                  
                  # Copy to build directory
                  subprocess.run(
                      ["cp", "-r", service_name, f"build/services/{full_version}"],
                      check=True
                  )
                  
                  # Record success
                  services_file.write(f"{service_name}:{full_version}:{version_ref}\n")
                  report_file.write(f"SUCCESS: {service_name} -> {full_version} (ref: {version_ref})\n")
                  print(f"  ✅ Built {full_version}")
                  success_count += 1
                  
              except Exception as e:
                  print(f"  ❌ Failed to build {service_name} @ {version_ref}: {e}")
                  report_file.write(f"FAILED: {service_name} @ {version_ref} - {str(e)}\n")
                  failed_count += 1
          
          services_file.close()
          report_file.close()
          
          print("\n📊 Build Summary:")
          print("-----------------")
          print(f"✅ Success: {success_count}")
          print(f"⚠️ Skipped: {skipped_count}")
          print(f"❌ Failed: {failed_count}")
          
          # Don't fail if services were skipped but some succeeded
          if success_count == 0:
              print("ERROR: No services were built successfully!")
              sys.exit(1)
          EOF
          
          python3 build_services.py
          
          echo ""
          echo "📊 Detailed Build Report:"
          cat build/build_report.txt | grep -E "^(SUCCESS|FAILED|SKIPPED)" || echo "No services built"
      
      - name: 📝 Create Manifest
        run: |
          # Check if services.txt exists and has content
          if [ ! -f "build/services.txt" ] || [ ! -s "build/services.txt" ]; then
            echo "⚠️ No services were built, creating empty manifest"
            echo '{"error": "No services built", "environment": "${{ inputs.environment }}"}' > build/manifest.json
          else
            python3 << 'EOF'
          import json
          import os
          from datetime import datetime
          
          services = {}
          update_order = []
          
          # Parse built services
          try:
              with open('build/services.txt') as f:
                  for line in f:
                      if line.strip():
                          parts = line.strip().split(':')
                          if len(parts) == 3:
                              name, version_dir, ref = parts
                              services[name] = {
                                  'version_directory': version_dir,
                                  'git_reference': ref,
                                  'built_at': datetime.utcnow().isoformat() + 'Z'
                              }
                              update_order.append(name)
          except FileNotFoundError:
              print("No services.txt found - no services were built")
              services = {}
          
          # Move hub-ota to the end if present
          if 'hub-ota' in update_order:
              update_order.remove('hub-ota')
              update_order.append('hub-ota')
          
          manifest = {
              'release_id': os.environ['GITHUB_RUN_ID'],
              'release_tag': os.environ.get('RELEASE_TAG', 'unknown'),
              'environment': '${{ inputs.environment }}',
              'thingsboard_tenant': os.environ.get('TB_TENANT', 'unknown'),
              'created_by': '${{ github.actor }}',
              'created_at': datetime.utcnow().isoformat() + 'Z',
              'release_notes': '''${{ inputs.release_notes }}''',
              'services': services,
              'update_order': update_order,
              'self_update': 'hub-ota' in services,
              'github_run_url': f"https://github.com/${{github.repository}}/actions/runs/${{github.run_id}}",
              'input_configuration': {
                  'services_requested': '${{ inputs.services_to_include }}',
                  'versions_requested': '${{ inputs.service_versions }}'
              }
          }
          
          with open('build/manifest.json', 'w') as f:
              json.dump(manifest, f, indent=2)
          
          print("📋 Manifest created successfully")
          print(json.dumps(manifest, indent=2))
          EOF
          fi
      
      - name: 📦 Create OTA Package
        run: |
          cd build
          zip -r ../ota_package_${{ inputs.environment }}.zip . -q
          cd ..
          
          echo "📦 Package created: ota_package_${{ inputs.environment }}.zip"
          echo "📏 Size: $(du -h ota_package_${{ inputs.environment }}.zip | cut -f1)"
          echo ""
          echo "📁 Package contents:"
          unzip -l ota_package_${{ inputs.environment }}.zip | head -30
      
      - name: 🔐 Sign Package
        env:
          DEV_KEY: ${{ secrets.OTA_SIGNING_KEY_DEV }}
          PROD_KEY: ${{ secrets.OTA_SIGNING_KEY_PROD }}
        run: |
          # FIXED: Proper way to handle the signing key
          if [ "${{ inputs.environment }}" == "production" ]; then
            SIGNING_KEY="$PROD_KEY"
            KEY_NAME="OTA_SIGNING_KEY_PROD"
          else
            SIGNING_KEY="$DEV_KEY"
            KEY_NAME="OTA_SIGNING_KEY_DEV"
          fi
          
          if [ -z "$SIGNING_KEY" ]; then
            echo "⚠️ Warning: No signing key found ($KEY_NAME)"
            echo "⚠️ Creating unsigned package for ${{ inputs.environment }}"
            
            mkdir final
            mv ota_package_${{ inputs.environment }}.zip final/package.zip
            cp build/manifest.json final/
            echo '{"signed": false, "environment": "${{ inputs.environment }}"}' > final/signature.json
          else
            echo "🔐 Signing package with $KEY_NAME"
            
            # Write the key to a file
            echo "$SIGNING_KEY" > private_key.pem
            
            # Verify it's a valid key
            if openssl rsa -in private_key.pem -check -noout 2>/dev/null; then
              echo "✅ Valid RSA key"
              
              # Sign the package
              openssl dgst -sha256 -sign private_key.pem \
                -out ota_package_${{ inputs.environment }}.zip.sig \
                ota_package_${{ inputs.environment }}.zip
              
              # Create final package with signature
              mkdir final
              mv ota_package_${{ inputs.environment }}.zip final/package.zip
              
              # Include signature as base64 in JSON
              SIGNATURE_B64=$(base64 -w0 ota_package_${{ inputs.environment }}.zip.sig)
              echo "{\"signature\":\"${SIGNATURE_B64}\", \"signed\": true, \"environment\": \"${{ inputs.environment }}\"}" > final/signature.json
              
              cp build/manifest.json final/
              
              # Clean up
              rm ota_package_${{ inputs.environment }}.zip.sig
            else
              echo "❌ Invalid key format, creating unsigned package"
              mkdir final
              mv ota_package_${{ inputs.environment }}.zip final/package.zip
              cp build/manifest.json final/
              echo '{"signed": false, "environment": "${{ inputs.environment }}", "error": "Invalid key format"}' > final/signature.json
            fi
            
            # Always clean up the key
            rm -f private_key.pem
          fi
          
          # Create final archive
          cd final
          FILENAME="ota_release_${{ inputs.environment }}_${TIMESTAMP}.zip"
          zip -r ../${FILENAME} . -q
          cd ..
          
          echo "RELEASE_FILENAME=${FILENAME}" >> $GITHUB_ENV
          echo "✅ Package ready: ${FILENAME}"
          echo "📏 Final size: $(du -h ${FILENAME} | cut -f1)"
      
      - name: 📤 Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ota-release-${{ inputs.environment }}-${{ github.run_id }}
          path: |
            ${{ env.RELEASE_FILENAME }}
            build/manifest.json
            build/build_report.txt
          retention-days: 30
      
      # ADDED: The missing GitHub Release creation step!
      - name: 📢 Create GitHub Release
        if: ${{ inputs.create_github_release == true }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          draft: false
          prerelease: ${{ inputs.environment == 'dev' }}
          files: |
            ${{ env.RELEASE_FILENAME }}
            build/manifest.json
            build/build_report.txt
          body: |
            ## 📦 OTA Release for ${{ inputs.environment }}
            
            **Release Engineer:** @${{ github.actor }}  
            **Build ID:** ${{ github.run_id }}  
            **Environment:** `${{ inputs.environment }}`  
            **ThingsBoard Tenant:** `${{ env.TB_TENANT }}`
            
            ### 📝 Release Notes
            ${{ inputs.release_notes }}
            
            ### 🔧 Services Configuration
            - **Requested:** `${{ inputs.services_to_include }}`
            - **Versions:** `${{ inputs.service_versions }}`
            
            ${{ inputs.include_hub_ota == true && '⚠️ **Warning:** This release includes hub-ota (self-update)' || '' }}
            
            ### 📥 Downloads
            - **OTA Package:** `${{ env.RELEASE_FILENAME }}`
            - **Manifest:** `manifest.json`
            - **Build Report:** `build_report.txt`
            
            ### 🚀 Deployment Instructions
            1. Download the OTA package from the release assets
            2. Verify the package signature (if signed)
            3. Upload to ThingsBoard ${{ inputs.environment }} tenant
            4. Deploy to target devices
            
            ---
            *Generated by [workflow run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*
      
      - name: 📊 Generate Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # 📦 OTA Release Build Complete
          
          ## Build Information
          | Property | Value |
          |----------|-------|
          | **Environment** | `${{ inputs.environment }}` |
          | **ThingsBoard Tenant** | `${{ env.TB_TENANT }}` |
          | **Release ID** | `${{ github.run_id }}` |
          | **Release Tag** | `${{ env.RELEASE_TAG }}` |
          | **Built by** | @${{ github.actor }} |
          
          ## Downloads
          EOF
          
          if [ "${{ inputs.create_github_release }}" == "true" ]; then
            echo "### 📢 GitHub Release Created!" >> $GITHUB_STEP_SUMMARY
            echo "**[View Release](https://github.com/${{ github.repository }}/releases/tag/${{ env.RELEASE_TAG }})**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**[⬇️ Download from Artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})**" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          
          ## Configuration Used
          - **Services**: `${{ inputs.services_to_include }}`
          - **Versions**: `${{ inputs.service_versions }}`
          - **Hub-OTA included**: ${{ inputs.include_hub_ota }}
          
          ## Release Notes
          ${{ inputs.release_notes }}
          
          ## Next Steps
          1. Download the OTA package from the GitHub Release
          2. Test on development devices first
          3. Upload to ThingsBoard ${{ inputs.environment }} tenant when ready
          EOF
          
          if [ "${{ inputs.include_hub_ota }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ **Warning**: This package includes hub-ota (self-update). The OTA service will update itself last." >> $GITHUB_STEP_SUMMARY
          fi
