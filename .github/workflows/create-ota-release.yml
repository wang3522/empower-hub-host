# .github/workflows/create-ota-release.yml
name: ðŸš€ Create OTA Release

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'ðŸŽ¯ Target Environment'
        type: choice
        options:
          - dev
          - production
        default: 'dev'
        required: true
      
      services_to_include:
        description: 'ðŸ“¦ Services (comma-separated: HubBL654Service,HubN2KService,HubOTAService,etc)'
        type: string
        default: 'HubBL654Service,HubProvisioningService,HubTBClientService,N2KClient,Scripts'
        required: true
      
      service_versions:
        description: 'ðŸ·ï¸ Versions (service:version pairs: HubBL654Service:main,HubOTAService:v1.2.3)'
        type: string
        default: 'HubBL654Service:main,HubProvisioningService:main,HubTBClientService:main,N2KClient:main'
        required: true
      
      forced_update:
        description: 'âš¡ Forced Update (bypasses user approval)'
        type: boolean
        default: false
      
      release_notes:
        description: 'ðŸ“ Release Notes'
        type: string
        required: true
      
      create_github_release:
        description: 'ðŸ“¢ Create GitHub Release'
        type: boolean
        default: true

jobs:
  build-release:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      contents: write  # Need this to create releases
    
    steps:
      - name: ðŸ“‹ Parse and Display Configuration
        id: parse
        run: |
          echo "========================================="
          echo "ðŸ“¦ OTA RELEASE BUILD"
          echo "========================================="
          echo "Environment: ${{ inputs.environment }} ðŸŽ¯"
          echo "Forced Update: ${{ inputs.forced_update }} âš¡"
          echo "Release Engineer: ${{ github.actor }}"
          echo "Build ID: ${{ github.run_id }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo ""
          echo "Parsing service configuration..."
          echo ""
          
          # Generate release tag with forced update indicator
          TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
          FORCED_SUFFIX=""
          if [ "${{ inputs.forced_update }}" == "true" ]; then
            FORCED_SUFFIX="-forced"
          fi
          
          if [ "${{ inputs.environment }}" == "production" ]; then
            RELEASE_TAG="release-prod-${TIMESTAMP}${FORCED_SUFFIX}"
            RELEASE_NAME="Production Release ${TIMESTAMP}${FORCED_SUFFIX}"
          else
            RELEASE_TAG="release-dev-${TIMESTAMP}${FORCED_SUFFIX}"
            RELEASE_NAME="Development Release ${TIMESTAMP}${FORCED_SUFFIX}"
          fi
          
          echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV
          echo "RELEASE_NAME=${RELEASE_NAME}" >> $GITHUB_ENV
          echo "TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV
          
          # Parse services and versions
          cat > parse_config.py << 'EOF'
          import sys
          import json
          import os
          
          services_input = "${{ inputs.services_to_include }}"
          versions_input = "${{ inputs.service_versions }}"
          
          # Parse services list
          services = [s.strip() for s in services_input.split(',') if s.strip()]
          
          # Parse versions into dict
          version_map = {}
          for pair in versions_input.split(','):
              if ':' in pair:
                  service, version = pair.strip().split(':', 1)
                  version_map[service.strip()] = version.strip()
          
          # Build final configuration
          config = {}
          for service in services:
              config[service] = version_map.get(service, 'main')
          
          # Check if HubOTAService is included for warning
          has_hub_ota = "HubOTAService" in config
          forced_update = "${{ inputs.forced_update }}" == "true"
          
          # Write to GitHub output file properly
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"SERVICE_CONFIG<<EOF\n")
              f.write(json.dumps(config, indent=2))
              f.write("\nEOF\n")
              f.write(f"HAS_HUB_OTA={str(has_hub_ota).lower()}\n")
              f.write(f"FORCED_UPDATE={str(forced_update).lower()}\n")
          
          # Display for logs (to stderr to avoid interfering with output)
          print("\nServices to Include:", file=sys.stderr)
          print("-------------------", file=sys.stderr)
          for service, version in config.items():
              marker = "âš ï¸" if service == "HubOTAService" else "âœ”"
              print(f"  {marker} {service} @ {version}", file=sys.stderr)
          
          if has_hub_ota:
              print("\nâš ï¸ WARNING: HubOTAService included - this enables self-update capability", file=sys.stderr)
          
          if forced_update:
              print("\nâš¡ FORCED UPDATE: This release will bypass user approval and deploy automatically", file=sys.stderr)
              if has_hub_ota:
                  print("âš ï¸ CRITICAL: Forced update with HubOTAService - use with extreme caution!", file=sys.stderr)
          
          print(f"\nTotal services: {len(config)}", file=sys.stderr)
          EOF
          
          python3 parse_config.py
          echo "========================================="
      
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: ðŸ” Verify Repository Structure
        run: |
          echo "=== Checking for expected service directories ==="
          for service in HubBL654Service HubN2KService HubProvisioningService HubTBClientService N2KClient HubOTAService; do
            if [ -d "$service" ]; then
              echo "âœ… Found: $service"
              echo "   Files: $(ls $service | head -3 | tr '\n' ' ')"
            else
              echo "âŒ Missing: $service"
            fi
          done
      
      - name: ðŸ”§ Setup Environment
        run: |
          if [ "${{ inputs.environment }}" == "production" ]; then
            echo "ðŸ”Œ Using production configuration"
            echo "SIGNING_KEY_NAME=OTA_SIGNING_KEY_PROD" >> $GITHUB_ENV
            echo "TB_TENANT=production-tenant" >> $GITHUB_ENV
          else
            echo "ðŸ”Œ Using development configuration"  
            echo "SIGNING_KEY_NAME=OTA_SIGNING_KEY_DEV" >> $GITHUB_ENV
            echo "TB_TENANT=dev-tenant" >> $GITHUB_ENV
          fi
      
      - name: ðŸ”¨ Build Service Packages
        run: |
          mkdir -p build/services
          echo "# Service Build Report" > build/build_report.txt
          echo "Environment: ${{ inputs.environment }}" >> build/build_report.txt
          echo "Forced Update: ${{ inputs.forced_update }}" >> build/build_report.txt
          echo "Build Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> build/build_report.txt
          echo "" >> build/build_report.txt
          
          # Parse service config - Updated for your directory structure
          cat > build_services.py << 'EOF'
          import json
          import subprocess
          import os
          import sys
          
          # Get service configuration from previous step
          config_json = '''${{ steps.parse.outputs.SERVICE_CONFIG }}'''
          config = json.loads(config_json)
          
          services_file = open("build/services.txt", "w")
          report_file = open("build/build_report.txt", "a")
          
          failed_count = 0
          success_count = 0
          skipped_count = 0
          
          # Map service names to deployment names (for /data/hub/ structure)
          SERVICE_TO_DEPLOYMENT = {
              'HubBL654Service': 'hub-bl654',
              'HubN2KService': 'hub-n2k',
              'HubProvisioningService': 'hub-provisioning',
              'HubTBClientService': 'hub-tbclient',
              'N2KClient': 'hub-n2kclient',
              'HubOTAService': 'hub-ota'
          }
          
          print("Checking for service directories...")
          existing_dirs = [d for d in os.listdir('.') if os.path.isdir(d) and (d.startswith('Hub') or d == 'N2KClient')]
          print(f"Found directories: {existing_dirs}")
          
          for service_name, version_ref in config.items():
              print(f"ðŸ“¦ Building {service_name}...")
              
              # Check if directory exists
              if not os.path.exists(service_name):
                  print(f"  âš ï¸ Warning: {service_name} directory not found, skipping")
                  report_file.write(f"SKIPPED: {service_name} - directory not found\n")
                  skipped_count += 1
                  continue
              
              try:
                  # Checkout specific version if not main
                  if version_ref != 'main':
                      result = subprocess.run(
                          ["git", "checkout", version_ref, "--", f"{service_name}/"],
                          capture_output=True,
                          text=True
                      )
                      
                      if result.returncode != 0:
                          # If it's a commit hash, try without the path restriction
                          if len(version_ref) >= 7 and all(c in '0123456789abcdef' for c in version_ref[:7]):
                              subprocess.run(
                                  ["git", "checkout", version_ref],
                                  check=True,
                                  capture_output=True
                              )
                  
                  # Get version string  
                  version_string = subprocess.run(
                      ["git", "describe", "--tags", "--always", "--long"],
                      capture_output=True,
                      text=True
                  ).stdout.strip()
                  
                  if not version_string:
                      version_string = subprocess.run(
                          ["git", "rev-parse", "--short", "HEAD"],
                          capture_output=True,
                          text=True
                      ).stdout.strip()
                  
                  # Use deployment name for the versioned directory
                  deployment_name = SERVICE_TO_DEPLOYMENT.get(service_name, service_name.lower())
                  full_version = f"{deployment_name}_{version_string}"
                  
                  # Copy to build directory with deployment name structure
                  subprocess.run(
                      ["cp", "-r", service_name, f"build/services/{full_version}"],
                      check=True
                  )
                  
                  # Record success with deployment name mapping
                  services_file.write(f"{deployment_name}:{full_version}:{version_ref}:{service_name}\n")
                  report_file.write(f"SUCCESS: {service_name} -> {full_version} (ref: {version_ref})\n")
                  print(f"  âœ… Built {full_version}")
                  success_count += 1
                  
              except Exception as e:
                  print(f"  âŒ Failed to build {service_name} @ {version_ref}: {e}")
                  report_file.write(f"FAILED: {service_name} @ {version_ref} - {str(e)}\n")
                  failed_count += 1
          
          services_file.close()
          report_file.close()
          
          print("\nðŸ“Š Build Summary:")
          print("-----------------")
          print(f"âœ… Success: {success_count}")
          print(f"âš ï¸ Skipped: {skipped_count}")
          print(f"âŒ Failed: {failed_count}")
          
          # Don't fail if services were skipped but some succeeded
          if success_count == 0:
              print("ERROR: No services were built successfully!")
              sys.exit(1)
          EOF
          
          python3 build_services.py
          
          echo ""
          echo "ðŸ“Š Detailed Build Report:"
          cat build/build_report.txt | grep -E "^(SUCCESS|FAILED|SKIPPED)" || echo "No services built"
          
          echo ""
          echo "ðŸ“¦ Package structure:"
          find build/services -type d -maxdepth 1 2>/dev/null | head -10
      
      - name: ðŸ“ Create Manifest
        run: |
          # Check if services.txt exists and has content
          if [ ! -f "build/services.txt" ] || [ ! -s "build/services.txt" ]; then
            echo "âš ï¸ No services were built, creating empty manifest"
            echo '{"error": "No services built", "environment": "${{ inputs.environment }}"}' > build/manifest.json
          else
            python3 << 'EOF'
          import json
          import os
          from datetime import datetime
          
          services = {}
          update_order = []
          
          # Parse built services
          try:
              with open('build/services.txt') as f:
                  for line in f:
                      if line.strip():
                          parts = line.strip().split(':')
                          if len(parts) >= 3:
                              # Format: deployment_name:version_dir:ref[:original_name]
                              name = parts[0]
                              version_dir = parts[1]
                              ref = parts[2]
                              original_name = parts[3] if len(parts) > 3 else name
                              
                              services[name] = {
                                  'version_directory': version_dir,
                                  'git_reference': ref,
                                  'original_directory': original_name,
                                  'built_at': datetime.utcnow().isoformat() + 'Z'
                              }
                              update_order.append(name)
          except FileNotFoundError:
              print("No services.txt found - no services were built")
              services = {}
          
          # Move hub-ota to the end if present (for safety during self-updates)
          if 'hub-ota' in update_order:
              update_order.remove('hub-ota')
              update_order.append('hub-ota')
          
          # Get forced update setting
          forced_update = '${{ inputs.forced_update }}' == 'true'
          
          manifest = {
              'release_id': os.environ['GITHUB_RUN_ID'],
              'release_tag': os.environ.get('RELEASE_TAG', 'unknown'),
              'environment': '${{ inputs.environment }}',
              'thingsboard_tenant': os.environ.get('TB_TENANT', 'unknown'),
              'created_by': '${{ github.actor }}',
              'created_at': datetime.utcnow().isoformat() + 'Z',
              'release_notes': '''${{ inputs.release_notes }}''',
              'services': services,
              'update_order': update_order,
              'forced_update': forced_update,
              'self_update': 'hub-ota' in services,
              'github_run_url': f"https://github.com/${{github.repository}}/actions/runs/${{github.run_id}}",
              'input_configuration': {
                  'services_requested': '${{ inputs.services_to_include }}',
                  'versions_requested': '${{ inputs.service_versions }}',
                  'forced_update_requested': forced_update
              }
          }
          
          with open('build/manifest.json', 'w') as f:
              json.dump(manifest, f, indent=2)
          
          print("ðŸ“‹ Manifest created successfully")
          if forced_update:
              print("âš¡ FORCED UPDATE: This release will bypass user approval")
          print(json.dumps(manifest, indent=2))
          EOF
          fi
      
      - name: ðŸ“¦ Create OTA Package
        run: |
          cd build
          zip -r ../ota_package_${{ inputs.environment }}.zip . -q
          cd ..
          
          echo "ðŸ“¦ Package created: ota_package_${{ inputs.environment }}.zip"
          echo "ðŸ“ Size: $(du -h ota_package_${{ inputs.environment }}.zip | cut -f1)"
          echo ""
          echo "ðŸ“ Package contents:"
          unzip -l ota_package_${{ inputs.environment }}.zip | grep -E "services/" | head -20
          echo ""
          echo "Total files: $(unzip -l ota_package_${{ inputs.environment }}.zip | tail -1)"
      
      - name: ðŸ” Sign Package
        env:
          DEV_KEY: ${{ secrets.OTA_SIGNING_KEY_DEV }}
          PROD_KEY: ${{ secrets.OTA_SIGNING_KEY_PROD }}
        run: |
          # Proper way to handle the signing key
          if [ "${{ inputs.environment }}" == "production" ]; then
            SIGNING_KEY="$PROD_KEY"
            KEY_NAME="OTA_SIGNING_KEY_PROD"
          else
            SIGNING_KEY="$DEV_KEY"
            KEY_NAME="OTA_SIGNING_KEY_DEV"
          fi
          
          if [ -z "$SIGNING_KEY" ]; then
            echo "âš ï¸ Warning: No signing key found ($KEY_NAME)"
            echo "âš ï¸ Creating unsigned package for ${{ inputs.environment }}"
            
            mkdir final
            mv ota_package_${{ inputs.environment }}.zip final/package.zip
            cp build/manifest.json final/
            echo '{"signed": false, "environment": "${{ inputs.environment }}", "forced_update": ${{ inputs.forced_update }}}' > final/signature.json
          else
            echo "ðŸ” Signing package with $KEY_NAME"
            
            # Write the key to a file
            echo "$SIGNING_KEY" > private_key.pem
            
            # Verify it's a valid key
            if openssl rsa -in private_key.pem -check -noout 2>/dev/null; then
              echo "âœ… Valid RSA key"
              
              # Sign the package
              openssl dgst -sha256 -sign private_key.pem \
                -out ota_package_${{ inputs.environment }}.zip.sig \
                ota_package_${{ inputs.environment }}.zip
              
              # Create final package with signature
              mkdir final
              mv ota_package_${{ inputs.environment }}.zip final/package.zip
              
              # Include signature as base64 in JSON
              SIGNATURE_B64=$(base64 -w0 ota_package_${{ inputs.environment }}.zip.sig)
              echo "{\"signature\":\"${SIGNATURE_B64}\", \"signed\": true, \"environment\": \"${{ inputs.environment }}\", \"forced_update\": ${{ inputs.forced_update }}}" > final/signature.json
              
              cp build/manifest.json final/
              
              # Clean up
              rm ota_package_${{ inputs.environment }}.zip.sig
            else
              echo "âŒ Invalid key format, creating unsigned package"
              mkdir final
              mv ota_package_${{ inputs.environment }}.zip final/package.zip
              cp build/manifest.json final/
              echo '{"signed": false, "environment": "${{ inputs.environment }}", "forced_update": ${{ inputs.forced_update }}, "error": "Invalid key format"}' > final/signature.json
            fi
            
            # Always clean up the key
            rm -f private_key.pem
          fi
          
          # Create final archive with forced update indicator in filename
          cd final
          FORCED_SUFFIX=""
          if [ "${{ inputs.forced_update }}" == "true" ]; then
            FORCED_SUFFIX="_forced"
          fi
          FILENAME="ota_release_${{ inputs.environment }}_${TIMESTAMP}${FORCED_SUFFIX}.zip"
          zip -r ../${FILENAME} . -q
          cd ..
          
          echo "RELEASE_FILENAME=${FILENAME}" >> $GITHUB_ENV
          echo "âœ… Package ready: ${FILENAME}"
          echo "ðŸ“ Final size: $(du -h ${FILENAME} | cut -f1)"
          
          if [ "${{ inputs.forced_update }}" == "true" ]; then
            echo "âš¡ WARNING: This is a FORCED UPDATE package - it will deploy automatically without user approval"
          fi
      
      - name: ðŸ“¤ Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ota-release-${{ inputs.environment }}-${{ github.run_id }}
          path: |
            ${{ env.RELEASE_FILENAME }}
            build/manifest.json
            build/build_report.txt
          retention-days: 30
      
      - name: ðŸ“¢ Create GitHub Release
        if: ${{ inputs.create_github_release == true }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_NAME }}
          draft: false
          prerelease: ${{ inputs.environment == 'dev' }}
          files: |
            ${{ env.RELEASE_FILENAME }}
            build/manifest.json
            build/build_report.txt
          body: |
            ## ðŸ“¦ OTA Release for ${{ inputs.environment }}
            
            **Release Engineer:** @${{ github.actor }}  
            **Build ID:** ${{ github.run_id }}  
            **Environment:** `${{ inputs.environment }}`  
            **ThingsBoard Tenant:** `${{ env.TB_TENANT }}`  
            **Forced Update:** `${{ inputs.forced_update }}`
            
            ${{ inputs.forced_update == true && 'âš¡ **CRITICAL WARNING: This is a FORCED UPDATE release that will deploy automatically without user approval!**' || '' }}
            
            ### ðŸ“ Release Notes
            ${{ inputs.release_notes }}
            
            ### ðŸ”§ Services Configuration
            - **Requested:** `${{ inputs.services_to_include }}`
            - **Versions:** `${{ inputs.service_versions }}`
            - **Forced Update:** `${{ inputs.forced_update }}`
            
            ${{ steps.parse.outputs.HAS_HUB_OTA == 'true' && 'âš ï¸ **Warning:** This release includes HubOTAService (self-update capability enabled)' || '' }}
            
            ${{ steps.parse.outputs.HAS_HUB_OTA == 'true' && inputs.forced_update == true && 'ðŸš¨ **EXTREME CAUTION:** Forced update with HubOTAService - this will automatically update the OTA system itself!' || '' }}
            
            ### ðŸ“¥ Downloads
            - **OTA Package:** `${{ env.RELEASE_FILENAME }}`
            - **Manifest:** `manifest.json`
            - **Build Report:** `build_report.txt`
            
            ### ðŸš€ Deployment Instructions
            1. Download the OTA package from the release assets
            2. Verify the package signature (if signed)
            3. Upload to ThingsBoard ${{ inputs.environment }} tenant
            4. Deploy to target devices
            ${{ inputs.forced_update == true && '   - **Note:** This update will deploy automatically without user confirmation' || '   - **Note:** This update will require user approval before deployment' }}
            
            ---
            *Generated by [workflow run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*
      
      - name: ðŸ“Š Generate Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # ðŸ“¦ OTA Release Build Complete
          
          ## Build Information
          | Property | Value |
          |----------|-------|
          | **Environment** | `${{ inputs.environment }}` |
          | **Forced Update** | `${{ inputs.forced_update }}` |
          | **ThingsBoard Tenant** | `${{ env.TB_TENANT }}` |
          | **Release ID** | `${{ github.run_id }}` |
          | **Release Tag** | `${{ env.RELEASE_TAG }}` |
          | **Built by** | @${{ github.actor }} |
          
          EOF
          
          if [ "${{ inputs.forced_update }}" == "true" ]; then
            echo "## âš¡ FORCED UPDATE WARNING" >> $GITHUB_STEP_SUMMARY
            echo "This release will **automatically deploy without user approval**!" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.parse.outputs.HAS_HUB_OTA }}" == "true" ]; then
              echo "ðŸš¨ **EXTREME CAUTION:** This includes HubOTAService self-update!" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## Downloads
          EOF
          
          if [ "${{ inputs.create_github_release }}" == "true" ]; then
            echo "### ðŸ“¢ GitHub Release Created!" >> $GITHUB_STEP_SUMMARY
            echo "**[View Release](https://github.com/${{ github.repository }}/releases/tag/${{ env.RELEASE_TAG }})**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**[â¬‡ï¸ Download from Artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})**" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          
          ## Configuration Used
          - **Services**: `${{ inputs.services_to_include }}`
          - **Versions**: `${{ inputs.service_versions }}`
          - **Forced Update**: `${{ inputs.forced_update }}`
          EOF
          
          if [ "${{ steps.parse.outputs.HAS_HUB_OTA }}" == "true" ]; then
            echo "- **âš ï¸ HubOTAService**: Included (self-update enabled)" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          
          ## Release Notes
          ${{ inputs.release_notes }}
          EOF
